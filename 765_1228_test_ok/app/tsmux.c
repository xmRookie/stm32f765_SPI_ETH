

#include "common.h"

//#define ES_BUF_SIZE 0x1000


//static uint8_t *es_stream;//[2][ES_BUF_SIZE];
//static uint8_t es_stream[TS_BUF_SIZE];

AV_TS_STREAM  av_ts_stream;

enum AVSTATEType {
    START_PACKET,
    VIDEO_PACKET,
    AUIDO_PACKET,
    END_PACKET
};

/**
 * Rounding methods.
 */
enum AVRounding {
    AV_ROUND_ZERO     = 0, ///< Round toward zero.
    AV_ROUND_INF      = 1, ///< Round away from zero.
    AV_ROUND_DOWN     = 2, ///< Round toward -infinity.
    AV_ROUND_UP       = 3, ///< Round toward +infinity.
    AV_ROUND_NEAR_INF = 5, ///< Round to nearest and halfway cases away from zero.
    /**
     * Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through
     * unchanged, avoiding special cases for #AV_NOPTS_VALUE.
     *
     * Unlike other values of the enumeration AVRounding, this value is a
     * bitmask that must be used in conjunction with another value of the
     * enumeration through a bitwise OR, in order to set behavior for normal
     * cases.
     *
     * @code{.c}
     * av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
     * // Rescaling 3:
     * //     Calculating 3 * 1 / 2
     * //     3 / 2 is rounded up to 2
     * //     => 2
     *
     * av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
     * // Rescaling AV_NOPTS_VALUE:
     * //     AV_NOPTS_VALUE == INT64_MIN
     * //     AV_NOPTS_VALUE is passed through
     * //     => AV_NOPTS_VALUE
     * @endcode
     */
    AV_ROUND_PASS_MINMAX = 8192,
};

#define FFMAX(a,b) ((a) > (b) ? (a) : (b))

#define TS_START_HEAR_LEN  24

static MpegTSWriteStream ts_st_v;
static MpegTSWriteStream ts_st_a;


static uint64_t tsPreCnt = 0;
static uint64_t tsCurCnt = 0;


enum AVSTATEType av_state;
static uint8_t pat_pmt_cc = 0;
static uint16_t v_pts_step = 0;
static uint16_t a_pts_step = 0;




//aud  0x0, 0x0, 0x0, 0x1, 0x9, 0x30,
//sps 0x0, 0x0, 0x0, 0x1, 0x67, 0x64, 0x0, 0x28, 0xac, 0x15, 0xa0, 0x14, 0x1, 0x6e, 0x84, 0x0, 0xd, 0xbb,0xa0, 0x6, 0x6f, 0xf3, 0x2, 0x10,
//pps 0x0, 0x0, 0x0, 0x1, 0x68, 0xee, 0x3e, 0x30,
//sei  0x0, 0x0, 0x0, 0x1, 0x6, 0x6, 0x1, 0xa4, 0x80,



const  uint8_t videoSPS[81]={
//vps 28
//	0x00,0x00,0x00,0x01,0x40,0x01,0x0C,0x01,0xFF,0xFF,0x01,0x60,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,
//	0x00,0x00,0x03,0x00,0x78,0xF0,0x24,
//sps 35
//	0xD9,0x00,0x65,0x74,0x00,0x00,0x72,0xEE,0xE2,0xF2,0x00,0x02,0x00,0x80,0x00,0x00,0x00,0x01,0x42,0x01,0x01,
//    0x01,0x60,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,
//pps 11
//	0x00,0x00,0x00,0x01,0x44,0x01,0xC1,0x90,0x95,0x81,0x12,
//IDR  # 0	 7
//	0x00,0x00,0x01,0x26,0x01,0xAC,0x66

	0x00,0x00,0x00,0x01,0x40,0x01,0x0C,0x01,0xFF,0xFF,0x01,0x60,0x00,0x00,0x03,0x00,0x00,0x03,
	0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x78,0xF0,0x24,
    0x00,0x00,0x00,0x01,0x42,0x01,0x01,0x01,0x60,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,0x00,0x03,0x00,
    0x78,0xA0,0x02,0x80,0x80,0x2D,0x1F,0xE5,0xF4,0xD3,0xC1,0xED,0x90,
    0x00,0x00,0x00,0x01,0x44,0x01,0xC0,0x90,0x95,0x81,0x12,
    0x00,0x00,0x01,0x26,0x01,0xAC,0x66
};

const  uint8_t mp2packt[] = {
    0xff, 0xfd, 0x84, 0x4, 0x44, 0x22, 0x22, 0x22, 0x11, 0x22, 0x11, 0x11,
    0x11, 0x11, 0x11, 0x24, 0x92, 0x52, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xaa, 0xa0, 0xfa, 0xa0, 0xaa, 0x5a, 0xf5, 0xaa, 0x4d, 0x36, 0x9a, 0x6d,
    0xb6, 0xde, 0x6d, 0xb7, 0x9b, 0x75, 0xa7, 0x5a, 0x71, 0xc7, 0x1c, 0x65,
    0xd6, 0x99, 0x75, 0xa6, 0xdb, 0x6d, 0xb7, 0x9d, 0x79, 0xd8, 0x20, 0x7e, 0x7,
    0xe0, 0x92, 0x39, 0x23, 0x92, 0x59, 0x24, 0x52, 0xf4, 0xa5, 0xe8, 0xc6,
    0x63, 0xad, 0xd6, 0xd9, 0xb3, 0x39, 0xf3, 0x66, 0x52, 0x8c, 0x66, 0xb6,
    0x10, 0x63, 0x25, 0x2b, 0x58, 0xe7, 0x10, 0x20, 0xe7, 0xdd, 0x31, 0xba,
    0x61, 0xb4, 0xda, 0xd, 0x86, 0xda, 0x34, 0x8c, 0x78, 0xf1, 0xa5, 0x10, 0x8b,
    0x58, 0xa5, 0x0, 0x12, 0x9b, 0xde, 0x94, 0x4e, 0x9c, 0x42, 0xdb, 0xc7, 0xb7,
    0x8f, 0x3b, 0x9d, 0x85, 0xc2, 0xd2, 0xa5, 0x4a, 0x5f, 0x3e, 0x63, 0x21, 0x0,
    0x86, 0xf7, 0x0, 0x2, 0x16, 0xb6, 0xd6, 0xa7, 0x4d, 0xad, 0x2a, 0x6, 0x54,
    0xd, 0x38, 0x9c, 0x65, 0xb2, 0xe6, 0xcd, 0x84, 0x5, 0x8b, 0x39, 0xe1, 0x6,
    0xb4, 0x21, 0x6b, 0x5a, 0xd6, 0xb6, 0xcd, 0x40, 0x85, 0xad, 0x12, 0x72,
    0x24, 0xe5, 0xc8, 0xe4, 0x6a, 0xb5, 0x66, 0x4c, 0x6b, 0x6f, 0x5e, 0x18,
    0xde, 0xf0, 0x86, 0xf7, 0x6b, 0x5a, 0xd4, 0xa7, 0x39, 0x80, 0xb2, 0x73,
    0xc2, 0xd5,
    0x85, 0xa9, 0x2a, 0x95, 0x8e, 0x47, 0x2b, 0x56, 0x52, 0x90, 0x20, 0x5a,
    0xe1, 0x4, 0xa5, 0x29, 0x21, 0x21, 0x4, 0xa5, 0xad, 0x85, 0x5, 0xad, 0xad,
    0xdf, 0x5b, 0xbd, 0xd6, 0xeb, 0x8a, 0x45, 0x13, 0x26, 0x6b, 0x6e, 0xdd,
    0x21, 0x0, 0xb, 0x36, 0x31, 0x6b, 0x5a, 0xd6, 0xb5, 0x2c, 0x4c, 0x98, 0x84,
    0x6a, 0x50, 0xd4, 0xa2, 0x29, 0x14, 0x9a, 0xcd, 0x6a, 0xd5, 0x6b, 0x5f,
    0xbf, 0x6b, 0x54, 0xa6, 0xb5, 0x29, 0xb5, 0x9a, 0xd8, 0x41, 0xad, 0x4, 0x9,
    0x4a, 0x7d, 0x60, 0xfa, 0xc1, 0xc6, 0xe3, 0xb5, 0xda, 0xcd, 0x9b, 0xbd,
    0xe1, 0xc3, 0x21, 0x27, 0x30, 0x1, 0x8, 0x6b, 0x5c, 0xe6, 0xb5, 0x8c, 0x76,
    0xee, 0xd6, 0x83, 0xdd, 0x7, 0xba, 0x25, 0x12, 0x45, 0x22, 0x9c, 0xb9, 0xb5,
    0xa2, 0x44, 0x8, 0x6b, 0x56, 0xb6, 0xb5, 0x10, 0x98, 0xc2, 0x95, 0xf0, 0xb9,
    0x85, 0xef, 0x8d, 0x71, 0x1a, 0xe1, 0xb4, 0xda, 0x45, 0x22, 0x9f, 0xbf,
    0xb5, 0x97, 0xaf, 0x9c, 0xed, 0x68, 0xc4, 0xa5, 0x63, 0x8, 0x46, 0xb5, 0x83,
    0x3e, 0x7d, 0xad, 0x5b, 0x34, 0xb6, 0x6a, 0x2b, 0x15, 0x8d, 0xc6, 0xdf,
    0x3e, 0x6b, 0x5f, 0x3e, 0x6b, 0x6b, 0x57, 0x39, 0x8c, 0x6b, 0x5c, 0xe7,
    0x39, 0xad, 0x7e, 0xfd, 0xad, 0x0, 0x0
};


const  uint8_t NULL_PACKET[TS_PACKET_SIZE] = {
    0x47, 0x1f, 0xff, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};
//    0x47, 0x40, 0x0, 0x10, 0x0, 0x0, 0xb0, 0xd, 0x0, 0x1, 0xc1, 0x0, 0x0, 0x0,
//    0x1, 0xf0, 0x0, 0x2a, 0xb1, 0x4, 0xb2, video
//     0x47, 0x40, 0x00, 0x10, 0x00, 0x00, 0xB0, 0x0D, 0x00, 0x01, 0xC1, 0x00, 0x00,  0x00, 
//    0x01, 0xF0, 0x00, 0x2A, 0xB1, 0x04, 0xB2  audio  pat

static uint8_t PAT_DAT[376] = {
    0x47, 0x40, 0x0, 0x10, 0x0, 0x0, 0xb0, 0xd, 0x0, 0x1, 0xc1, 0x0, 0x0, 0x0,
    0x1, 0xf0, 0x0, 0x2a, 0xb1, 0x4, 0xb2,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
//};

//h264
//0x47, 0x50, 0x0, 0x10, 
//0x00, 0x02, 0xb0, 0x17, 0x00, 0x01, 0xc1, 0x00, 0x00, 0xe1, 0x00, 0xf0, 0x00,
//0x1b, 0xe1, 0x00, 0xf0, 0x00, 0x03, 0xe1, 0x01, 0xf0, 0x00,0x4e, 0x59, 0x3d, 0x1e,

//h265 
//0x47, 0x50, 0x00, 0x10,
//0x00, 0x02, 0xB0, 0x17, 0x00, 0x01, 0xC1, 0x00, 0x00, 0xE1, 0x00, 0xF0, 0x00, 
//0x24, 0xE1, 0x00, 0xF0, 0x00, 0x0F, 0xE1, 0x01, 0xF0, 0x00, 0xC7, 0x72, 0xB7, 0xCB ,

//0x47, 0x50, 0x00, 0x10,
//0x00, 0x02, 0xB0, 0x17, 0x00, 0x01, 0xC1, 0x00, 0x00, 0xE1, 0x00, 0xF0, 0x00, 
//0x24, 0xE1, 0x00, 0xF0, 0x00, 0x03, 0xE1, 0x01, 0xF0, 0x00, 0xA6, 0x6F, 0x33, 0x4E ,

//static uint8_t PMT_DAT[TS_PACKET_SIZE] = {

////0x47, 0x50, 0x00, 0x10, 
//  0x00, 0x02, 0xB0, 0x12, 0x00, 0x01, 0xC1, 0x00, 0x00, 0xE1, 0x00, 0xF0, 0x00, 
//  0x0F, 0xE1, 0x00, 0xF0, 0x00, 0xB6, 0x9B, 0xC0, 0xD9  audio pmt
	0x47, 0x50, 0x00, 0x10,
	0x00, 0x02, 0xB0, 0x17, 0x00, 0x01, 0xC1, 0x00, 0x00, 0xE1, 0x00, 0xF0, 0x00, 
	0x24, 0xE1, 0x00, 0xF0, 0x00, 0x03, 0xE1, 0x01, 0xF0, 0x00, 0xA6, 0x6F, 0x33, 0x4E ,

    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};


static int write_pcr_bits(uint8_t *buf, int64_t pcr)
{
    int64_t pcr_low = pcr % 300, pcr_high = pcr / 300;

    *buf++ = pcr_high >> 25;
    *buf++ = pcr_high >> 17;
    *buf++ = pcr_high >>  9;
    *buf++ = pcr_high >>  1;
    *buf++ = pcr_high <<  7 | pcr_low >> 8 | 0x7e;
    *buf++ = pcr_low;

    return 6;
}

static void write_pts(uint8_t *q, int fourbits, int64_t pts)
{
    int val;

    val  = fourbits << 4 | (((pts >> 30) & 0x07) << 1) | 1;
    *q++ = val;
    val  = (((pts >> 15) & 0x7fff) << 1) | 1;
    *q++ = val >> 8;
    *q++ = val;
    val  = (((pts) & 0x7fff) << 1) | 1;
    *q++ = val >> 8;
    *q++ = val;
}

/* Set an adaptation field flag in an MPEG-TS packet*/
static void set_af_flag(uint8_t *pkt, int flag)
{
    // expect at least one flag to set
    //av_assert0(flag);

    if((pkt[3] & 0x20) == 0) {
        // no AF yet, set adaptation field flag
        pkt[3] |= 0x20;
        // 1 byte length, no flags
        pkt[4] = 1;
        pkt[5] = 0;
    }

    pkt[5] |= flag;
}

/* Extend the adaptation field by size bytes */
static void extend_af(uint8_t *pkt, int size)
{
    // expect already existing adaptation field
    //av_assert0(pkt[3] & 0x20);
    pkt[4] += size;
}

/* Get a pointer to MPEG-TS payload (right after TS packet header) */
static uint8_t *get_ts_payload_start(uint8_t *pkt)
{
    if(pkt[3] & 0x20)
        return pkt + 5 + pkt[4];
    else
        return pkt + 4;
}

/* Write a single null transport stream packet */
#if 0
static void mpegts_insert_null_packet(void)
{
    uint8_t *q;
    uint8_t buf[TS_PACKET_SIZE];

    q    = buf;
    *q++ = 0x47;
    *q++ = 0x00 | 0x1f;
    *q++ = 0xff;
    *q++ = 0x10;
    memset(q, 0x0FF, TS_PACKET_SIZE - (q - buf));

    udp_send_to_host(buf, TS_PACKET_SIZE);

}
#endif

int64_t tsmux_av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
{
    int64_t r = 0;
    //av_assert2(c > 0);
   // av_assert2(b >=0);
   // av_assert2((unsigned)(rnd&~AV_ROUND_PASS_MINMAX)<=5 && (rnd&~AV_ROUND_PASS_MINMAX)!=4);

    if (c <= 0 || b < 0 || !((unsigned)(rnd&~AV_ROUND_PASS_MINMAX)<=5 && (rnd&~AV_ROUND_PASS_MINMAX)!=4))
        return INT64_MIN;

    if (rnd & AV_ROUND_PASS_MINMAX) {
        if (a == INT64_MIN || a == INT64_MAX)
            return a;
        rnd -= AV_ROUND_PASS_MINMAX;
    }

    if (a < 0)
        return -(uint64_t)tsmux_av_rescale_rnd(-FFMAX(a, -INT64_MAX), b, c, rnd ^ ((rnd >> 1) & 1));

    if (rnd == AV_ROUND_NEAR_INF)
        r = c / 2;
    else if (rnd & 1)
        r = c - 1;

    if (b <= INT32_MAX && c <= INT32_MAX) {
        if (a <= INT32_MAX)
            return (a * b + r) / c;
        else {
            int64_t ad = a / c;
            int64_t a2 = (a % c * b + r) / c;
            if (ad >= INT32_MAX && b && ad > (INT64_MAX - a2) / b)
                return INT64_MIN;
            return ad * b + a2;
        }
    } else {
        uint64_t a0  = a & 0xFFFFFFFF;
        uint64_t a1  = a >> 32;
        uint64_t b0  = b & 0xFFFFFFFF;
        uint64_t b1  = b >> 32;
        uint64_t t1  = a0 * b1 + a1 * b0;
        uint64_t t1a = t1 << 32;
        int i;

        a0  = a0 * b0 + t1a;
        a1  = a1 * b1 + (t1 >> 32) + (a0 < t1a);
        a0 += r;
        a1 += a0 < r;

        for (i = 63; i >= 0; i--) {
            a1 += a1 + ((a0 >> i) & 1);
            t1 += t1;
            if (c <= a1) {
                a1 -= c;
                t1++;
            }
        }
        if (t1 > INT64_MAX)
            return INT64_MIN;
        return t1;

    }
}

int64_t tsmux_av_rescale(int64_t a, int64_t b, int64_t c)
{
    return tsmux_av_rescale_rnd(a, b, c, AV_ROUND_NEAR_INF);
}

int audio_mpegts_start_packet(MpegTSWriteStream *ts_st)
{
    uint8_t buf[TS_PACKET_SIZE];
    int64_t delay = 0;//av_rescale(2, 90000, AV_TIME_BASE);
    int64_t pcr = -1;
    uint8_t *q;
    int val,  len, header_len, flags;
    int64_t pts, dts;
    uint8_t *payload;
    int payload_size;
	

	payload = ts_st->payload;
    payload_size = ts_st->payload_size;

	pts =  ts_st->payload_pts;
    dts =  ts_st->payload_pts;
    q    = buf;
    *q++ = 0x47;
    val  = ts_st->pid >> 8;
    val |= 0x40;
    *q++      = val;
    *q++      = ts_st->pid;
    ts_st->cc = (ts_st->cc + 1) & 0xf;
    *q++      = 0x10 | ts_st->cc; // payload indicator + CC
    set_af_flag(buf, 0x40);
    q = get_ts_payload_start(buf);

    if(ts_st->codec_type == AVMEDIA_TYPE_VIDEO) { //wirte pcr
        set_af_flag(buf, 0x10);
        q = get_ts_payload_start(buf);
        pcr = (dts - delay) * 300;
        extend_af(buf, write_pcr_bits(q, pcr));
        q = get_ts_payload_start(buf);
    }

    *q++ = 0x00;
    *q++ = 0x00;
    *q++ = 0x01;

    if(ts_st->codec_type == AVMEDIA_TYPE_VIDEO) {
        *q++ = 0xe0;
    } else if(ts_st->codec_type == AVMEDIA_TYPE_AUDIO) {
        *q++ = 0xc0;
    }

    header_len = 0;
    flags      = 0;

    if(pts != AV_NOPTS_VALUE) {
        header_len += 5;
        flags      |= 0x80;
    }

    len = payload_size + header_len + 3;

    if(len > 0xffff)
        len = 0;

    if(ts_st->codec_type == AVMEDIA_TYPE_VIDEO) {
        len = 0;
    }

    *q++ = len >> 8;
    *q++ = len;
    val  = 0x80;

    *q++ = val;
    *q++ = flags;
    *q++ = header_len;

    if(pts != AV_NOPTS_VALUE) {
        write_pts(q, flags >> 6, pts);
        q += 5;
    }

    /* header size */
    header_len = q - buf;
    /* data len */
    len = TS_PACKET_SIZE - header_len;
    //memcpy(buf + header_len, payload, len);
    udp_Send_Pack(buf, header_len,payload, len);

	

		ts_st->payload      += len;
    ts_st->payload_size -= len;

		
    //udp_send_to_host(buf, TS_PACKET_SIZE);

    return len;
}

int mpegts_start_packet(MpegTSWriteStream *ts_st)
{
    uint8_t buf[TS_PACKET_SIZE];
    int64_t delay = 0;//av_rescale(2, 90000, AV_TIME_BASE);
    int64_t pcr = -1;
    uint8_t *q;
    int val,  len, header_len, flags;
    int64_t pts, dts;
    uint8_t *payload;
    int payload_size;
#if 1
    payload = ts_st->payload+TS_START_HEAR_LEN; //-24;//  image
    payload_size = ts_st->payload_size-TS_START_HEAR_LEN; //24;//----
#else	
    payload = ts_st->payload;
    payload_size = ts_st->payload_size;
#endif
	pts =  ts_st->payload_pts;
    dts =  ts_st->payload_pts;
    q    = buf;
    *q++ = 0x47;
    val  = ts_st->pid >> 8;
    val |= 0x40;
    *q++      = val;
    *q++      = ts_st->pid;
    ts_st->cc = (ts_st->cc + 1) & 0xf;
    *q++      = 0x10 | ts_st->cc; // payload indicator + CC
    set_af_flag(buf, 0x40);
    q = get_ts_payload_start(buf);

    if(ts_st->codec_type == AVMEDIA_TYPE_VIDEO) { //wirte pcr
        set_af_flag(buf, 0x10);
        q = get_ts_payload_start(buf);
        pcr = (dts - delay) * 300;
        extend_af(buf, write_pcr_bits(q, pcr));
        q = get_ts_payload_start(buf);
    }

    *q++ = 0x00;
    *q++ = 0x00;
    *q++ = 0x01;

    if(ts_st->codec_type == AVMEDIA_TYPE_VIDEO) {
        *q++ = 0xe0;
    } else if(ts_st->codec_type == AVMEDIA_TYPE_AUDIO) {
        *q++ = 0xc0;
    }

    header_len = 0;
    flags      = 0;

    if(pts != AV_NOPTS_VALUE) {
        header_len += 5;
        flags      |= 0x80;
    }

    len = payload_size + header_len + 3;

    if(len > 0xffff)
        len = 0;

    if(ts_st->codec_type == AVMEDIA_TYPE_VIDEO) {
        len = 0;
    }

    *q++ = len >> 8;
    *q++ = len;
    val  = 0x80;

    *q++ = val;
    *q++ = flags;
    *q++ = header_len;

    if(pts != AV_NOPTS_VALUE) {
        write_pts(q, flags >> 6, pts);
        q += 5;
    }

    /* header size */
    header_len = q - buf;
    /* data len */
    len = TS_PACKET_SIZE - header_len;
    //memcpy(buf + header_len, payload, len);
    udp_Send_Pack(buf, header_len,payload, len);
#if 0
		payload += len;  //image
		payload_size -= len;
#else		
    ts_st->payload = payload;  //len;
    ts_st->payload_size = payload_size;   //len;
#endif
		ts_st->payload      += len;
    ts_st->payload_size -= len;

		
    //udp_send_to_host(buf, TS_PACKET_SIZE);

    return len;
}

//const uint8_t *payload, int payload_size,
int mpegts_normal_packet(MpegTSWriteStream *ts_st)
{
    uint8_t buf[TS_PACKET_SIZE];
    //int64_t delay = 0;//av_rescale(0, 90000, AV_TIME_BASE);
    int afc_len, stuffing_len;
    uint8_t *q;
    int len, header_len;
    uint8_t *payload;
    int payload_size;
    payload = ts_st->payload;
    payload_size = ts_st->payload_size;

    /* prepare packet header */
    while(payload_size > 0) {
        q    = buf;
        *q++ = 0x47;
        *q++      =  ts_st->pid >> 8;
        *q++      = ts_st->pid;
        ts_st->cc = (ts_st->cc + 1) & 0xf;
        *q++      = 0x10 | ts_st->cc; // payload indicator + CC
        /* header size */
        header_len = q - buf;
        /* data len */
        len = TS_PACKET_SIZE - header_len;

        if(len > payload_size)
            len = payload_size;

        stuffing_len = TS_PACKET_SIZE - header_len - len;

        if(stuffing_len > 0) {
            /* add stuffing with AFC */
            if(buf[3] & 0x20) {
                /* stuffing already present: increase its size */
                afc_len = buf[4] + 1;
                memmove(buf + 4 + afc_len + stuffing_len,
                        buf + 4 + afc_len,
                        header_len - (4 + afc_len));
                buf[4] += stuffing_len;
                memset(buf + 4 + afc_len, 0xff, stuffing_len);
            } else {
                /* add stuffing */
                memmove(buf + 4 + stuffing_len, buf + 4, header_len - 4);
                buf[3] |= 0x20;
                buf[4]  = stuffing_len - 1;

                if(stuffing_len >= 2) {
                    buf[5] = 0x00;
                    memset(buf + 6, 0xff, stuffing_len - 2);
                }
            }
        }

        /* data len */
		//memcpy(buf + TS_PACKET_SIZE - len, payload, len);
    	udp_Send_Pack(buf,TS_PACKET_SIZE - len,payload, len);
	
		payload      += len;
        payload_size -= len;
		//ts_st->payload      += len;
        //ts_st->payload_size -= len;
    }
	ts_st->payload = payload;
    ts_st->payload_size = payload_size;
    return len;
   
}


//static uint8_t PMT_DAT[TS_PACKET_SIZE]={
//};


int test_normal_packet(MpegTSWriteStream *ts_st)
{
	uint8_t buf[TS_PACKET_SIZE];
	uint8_t *q;
	int len;
	uint8_t *payload;
	int payload_size;
	q= buf;
	payload = ts_st->payload;
	payload_size = ts_st->payload_size;
	len = 376;

	/* prepare packet header */
	while(payload_size > len) {
		write_pts(q, 0, 1920);
		write_pts(q, 0, 1920);
		udp_Send_Pack(payload,len,buf, 0);
		tsCurCnt+=len;
		payload 	 += len;
		payload_size -= len;
	}
	if(payload_size)
	{
		write_pts(q, 0, 1920);
		write_pts(q, 0, 1920);
		udp_Send_Pack(payload,payload_size,buf, 0);
		tsCurCnt+=payload_size;
		payload_size = 0;
	}
	ts_st->payload = payload;
	ts_st->payload_size = payload_size;
	return len;
	   
}

static inline double av_q2d(AVRational a)
{
    return a.num / (double) a.den;
}

extern void tsMux_init(void)
{
    //int len_v,len_a;
	//int cnt;

	memset(&ts_st_v,0,sizeof(ts_st_v));
	memset(&ts_st_a,0,sizeof(ts_st_a));
    pat_pmt_cc = 0;

	v_pts_step = 90000/60;//1500 3600 25fps
	a_pts_step = 2160;
    ts_st_v.codec_type = AVMEDIA_TYPE_VIDEO;
    ts_st_v.pid = 256;
    ts_st_v.cc = 15;
    ts_st_v.payload_pts = 0;
	ts_st_v.payload_size = 0;
    ts_st_a.codec_type = AVMEDIA_TYPE_AUDIO;
    ts_st_a.pid = 257;
    ts_st_a.cc = 15;
    ts_st_a.payload_pts = 0;

    av_state = END_PACKET;

	//av_ts_stream.maxlen = ES_BUF_SIZE;

	//pack_quene[0].p=h264packt_1;
	//pack_quene[0].len = sizeof(h264packt_1);

    //test_loop = 0;
    //memset(es_stream,0x00,sizeof(es_stream));


}


extern void Start_TS_Frame(void)
{
#ifndef TEST_UDP
	PAT_DAT[3] = 0x10 | pat_pmt_cc; // payload indicator + CC
    PAT_DAT[3+TS_PACKET_SIZE] =PAT_DAT[3];
       // PMT_DAT[3] = PAT_DAT[3]; // payload indicator + CC
    pat_pmt_cc = (pat_pmt_cc + 1) & 0xf;
 
	udp_Send_Pack(PAT_DAT, sizeof(PAT_DAT),PAT_DAT,0);

	ts_st_a.payload_flags = 1;

	ts_st_v.is_start = 1;
#else
	ts_st_v.is_start = 1;
	udp_Send_Pack((uint8_t*)videoSPS, sizeof(videoSPS),PAT_DAT,0);
#endif

}


extern void  Start_Audio_Frame(void)
{
	ts_st_a.is_start = 1;
}



extern uint8_t  Get_Audio_enflag(void)
{
	return ts_st_a.payload_flags;
}


extern void ReflashVideoPack(void)
{
	av_ts_stream.Write = 0;
	av_ts_stream.Read = 0;
	ts_st_v.payload = NULL;
	av_state = END_PACKET;
}

extern void PackAudioTs(uint8_t *buf,uint16_t len)
{

	int64_t tmp_pts;
	ts_st_a.payload = buf;//mp2packt
	//if(len != 2304)
	//{
	//	printf("error audio len %d\r\n",len);
	//	len = 2304   ;
	//}
	ts_st_a.payload_size = len;
	//ts_st_a.is_start = 1;
	while(ts_st_a.payload_size > 0)
	{
	       if(ts_st_a.is_start) {
            ts_st_a.is_start = 0;
            audio_mpegts_start_packet(&ts_st_a);
            ts_st_a.payload_pts += a_pts_step;
			tmp_pts = ts_st_a.payload_pts + a_pts_step;
			if(tmp_pts < ts_st_v.payload_pts)
			{
				ts_st_a.payload_pts = tmp_pts;
			}
        } else {
            mpegts_normal_packet(&ts_st_a);
        }
	}   

}

extern void PackVideoTs(uint8_t *buf,uint16_t len)
{
    uint8_t *payload;
	int payload_size;
	

	ts_st_v.payload = buf;
	ts_st_v.payload_size = len;
	
	while(ts_st_v.payload_size > 0)
	{
#ifndef TEST_UDP
		//	Status_busy(1);
	        if(ts_st_v.is_start) {
	           ts_st_v.is_start = 0;
			   //ts_st_v.payload = &es_stream[av_ts_stream.Read];
	           //av_ts_stream.Read += mpegts_start_packet(&ts_st_v);
	           payload=ts_st_v.payload+TS_START_HEAR_LEN;
			   memcpy((uint8_t*)(payload), (uint8_t*)(videoSPS), sizeof(videoSPS));
	           mpegts_start_packet(&ts_st_v);
	           ts_st_v.payload_pts += v_pts_step; //90000/60;
	           // ts_st_v.payload_size = av_ts_stream.Write - av_ts_stream.Read;
	        } else {
	           //
	           //av_ts_stream.Read += mpegts_normal_packet(&ts_st_v);
			    mpegts_normal_packet(&ts_st_v);
			   //ts_st_v.payload = &es_stream[av_ts_stream.Read];
	        }
		//	Status_busy(0);
#else
		if(ts_st_v.is_start)
		{
			ts_st_v.is_start = 0;
			payload = ts_st_v.payload+105;
			payload_size = ts_st_v.payload_size-105;
			ts_st_v.payload = payload;
			ts_st_v.payload_size = payload_size;
			if(tsPreCnt != tsCurCnt)
			{
			     tsPreCnt = tsCurCnt;
				 //USART3_Putbuf((uint8_t *)&precnt,4);
				 //printf(" ts index i %lld",tsCurCnt);
			}
			tsCurCnt = 0;
		}
	    test_normal_packet(&ts_st_v);
#endif
	}   
	pollint_Audio_TS();
	//PackAudioTs(mp2packt,sizeof(mp2packt));
	
}


extern uint8_t GetTSmuxState(void)
{
	if(ts_st_v.payload_size == 0)
	{
		return TS_MUX_IDLE;
	}
	else
	{
		return TS_MUX_BUSY;	
	}
}


extern uint8_t GetTSmuxAudioState(void)
{
	if(ts_st_a.payload_size == 0  && udp_GetState() == HAL_ETH_STATE_READY)
	{
		return TS_MUX_IDLE;
	}
	else
	{
		return TS_MUX_BUSY;	
	}
}


extern void Delay_4ms(void)
{
	//Status_busy(1);
	uint16_t cycle_index1;
	uint16_t cycle_index2;
	for(cycle_index1=0; cycle_index1<2000; cycle_index1++){
		for(cycle_index2=0; cycle_index2<113; cycle_index2++);
	}
	//Status_busy(0);
}

//static uint8_t packet_q[3][1316];//188*7

//struct udp_tx_buf{
//	int write;
//	int read;
//	char busy;
//	int count;
//}


